# taskfiles/ai.yml
# Commandes IA avec Claude CLI pour le développement
# Usage: task ai:git:commit
#
# Ce fichier utilise Claude Code CLI pour:
# - Génération de messages de commit
# - Review de code
# - Documentation
# - Tests

version: '3'

silent: true

# ============================================================================
# VARIABLES GLOBALES
# ============================================================================
vars:
  AI_PROVIDER: '{{.AI_PROVIDER | default "claude"}}'  # claude ou ollama
  AI_LANG: '{{.AI_LANG | default "fr"}}'

  # Modèles par provider (permet d'avoir les deux configurés indépendamment)
  _CLAUDE_MODEL: '{{.CLAUDE_MODEL | default "haiku"}}'         # haiku, sonnet, opus
  _OLLAMA_MODEL: '{{.OLLAMA_MODEL | default "qwen2.5-coder:14b"}}'  # ou llama3.2, etc.

  # AI_MODEL = automatiquement le bon selon le provider
  AI_MODEL: '{{if eq .AI_PROVIDER "claude"}}{{._CLAUDE_MODEL}}{{else}}{{._OLLAMA_MODEL}}{{end}}'

  # Couleurs
  PRIMARY: "212"
  SECONDARY: "99"
  SUCCESS: "42"
  ERROR: "196"
  WARNING: "226"
  MUTED: "240"

# ============================================================================
# INCLUDES
# ============================================================================
includes:
  ui:
    taskfile: ./ui.yml
    internal: true
  utils:
    taskfile: ./utils.yml
    internal: true

# ============================================================================
# TACHES
# ============================================================================
tasks:
  # --------------------------------------------------------------------------
  # CHECKS INTERNES
  # --------------------------------------------------------------------------
  _check-tools:
    internal: true
    cmds:
      - task: utils:check-tools

  _check-claude:
    internal: true
    cmds:
      - |
        if ! command -v claude &>/dev/null; then
          gum style --foreground {{.ERROR}} " Claude CLI non installé"
          gum style --foreground {{.MUTED}} "   Installe-le: https://claude.ai/code"
          exit 1
        fi

  _check-ollama:
    internal: true
    cmds:
      - task: utils:check-ollama

  _check-ai:
    internal: true
    cmds:
      - |
        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          if ! command -v claude &>/dev/null; then
            gum style --foreground {{.ERROR}} " Claude CLI non installé"
            gum style --foreground {{.MUTED}} "   Installe-le: https://claude.ai/code"
            exit 1
          fi
        else
          if ! command -v ollama &>/dev/null; then
            gum style --foreground {{.ERROR}} " Ollama CLI non installé"
            gum style --foreground {{.MUTED}} "   Installe-le: https://ollama.ai"
            exit 1
          fi
          if ! ollama list &>/dev/null 2>&1; then
            gum style --foreground {{.ERROR}} " Ollama non disponible"
            gum style --foreground {{.MUTED}} "   Lance: ollama serve"
            exit 1
          fi
        fi

  # --------------------------------------------------------------------------
  # MENU PAR DEFAUT
  # --------------------------------------------------------------------------
  default:
    desc: "Affiche les commandes AI disponibles"
    cmds:
      - clear
      - task: ui:header
        vars: {TITLE: "AI - OUTILS INTELLIGENCE ARTIFICIELLE", COLOR: "{{.PRIMARY}}"}
      - task: ui:spacer
      - task: ui:section
        vars: {TITLE: " Git & Workflow:"}
      - task: ui:info
        vars: {TEXT: "  task ai:git          - Menu Git (commit, pr, merge, branch, tag)"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:main     - Workflow complet (commit + PR + merge)"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:commit   - Commit YOLO (auto add + commit + push)"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:pr       - Creer une Pull Request avec IA"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:merge    - Merger une Pull Request"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:branch   - Creer une branche (Conventional Commits)"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:tag      - Creer un tag versionne (semver)"}
      - task: ui:spacer
      - task: ui:section
        vars: {TITLE: " Code Analysis:"}
      - task: ui:info
        vars: {TEXT: "  task ai:review       - Review du code (staged/unstaged)"}
      - task: ui:info
        vars: {TEXT: "  task ai:explain      - Expliquer du code selectionne"}
      - task: ui:info
        vars: {TEXT: "  task ai:docs         - Generer documentation (JSDoc/README)"}
      - task: ui:info
        vars: {TEXT: "  task ai:test         - Generer des tests (Vitest/Jest)"}
      - task: ui:spacer
      - task: ui:section
        vars: {TITLE: " Config:"}
      - task: ui:info
        vars: {TEXT: "  task ai:config       - Configuration IA"}
      - task: ui:info
        vars: {TEXT: "  task ai:hello        - Test du systeme Claude CLI"}
      - task: ui:spacer
      - task: ui:muted
        vars: {TEXT: "  Provider: {{.AI_PROVIDER}} | Model: {{.AI_MODEL}}"}
      - task: ui:spacer

  # --------------------------------------------------------------------------
  # MENU GIT
  # --------------------------------------------------------------------------

  git:
    desc: "Menu Git - commit, pr, merge, branch, tag, main"
    cmds:
      - clear
      - task: ui:header
        vars: {TITLE: "AI:GIT - OUTILS GIT AVEC IA", COLOR: "{{.PRIMARY}}"}
      - task: ui:spacer
      - task: ui:info
        vars: {TEXT: "  task ai:git:main     - Workflow complet (commit + PR + merge)"}
      - task: ui:spacer
      - task: ui:info
        vars: {TEXT: "  task ai:git:commit   - Commit YOLO (auto add + commit + push)"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:pr       - Creer une Pull Request avec IA"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:merge    - Merger une Pull Request"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:branch   - Creer une branche (Conventional Commits)"}
      - task: ui:info
        vars: {TEXT: "  task ai:git:tag      - Creer un tag versionne (semver)"}
      - task: ui:spacer
      - task: ui:muted
        vars: {TEXT: "  Provider: {{.AI_PROVIDER}} | Model: {{.AI_MODEL}}"}
      - task: ui:spacer

  # --------------------------------------------------------------------------
  # GIT:MAIN - Workflow complet: commit + PR + merge
  # --------------------------------------------------------------------------

  git:main:
    desc: "Workflow complet: commit + PR + merge (fin de sprint)"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} --bold -- "--- WORKFLOW FIN DE SPRINT ---"
        echo ""

        # Vérifier que gh est installé et authentifié
        if ! command -v gh &>/dev/null; then
          gum style --foreground {{.ERROR}} " GitHub CLI (gh) non installé"
          exit 1
        fi
        if ! gh auth status &>/dev/null; then
          gum style --foreground {{.ERROR}} " GitHub CLI non authentifié"
          exit 1
        fi

        CURRENT_BRANCH=$(git branch --show-current)

        # Détecter la branche principale
        if git show-ref --verify --quiet refs/heads/main; then
          BASE_BRANCH="main"
        else
          BASE_BRANCH="master"
        fi

        if [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
          gum style --foreground {{.ERROR}} " Tu es sur $BASE_BRANCH - crée d'abord une branche feature"
          exit 1
        fi

        gum style --foreground {{.MUTED}} "Branche: $CURRENT_BRANCH → $BASE_BRANCH ({{.AI_PROVIDER}}/{{.AI_MODEL}})"
        echo ""

        # ETAPE 1: COMMIT
        gum style --foreground {{.PRIMARY}} "├─ ETAPE 1/3: COMMIT"

        MODIFIED=$(git diff --name-only 2>/dev/null)
        STAGED=$(git diff --cached --name-only 2>/dev/null)
        UNTRACKED=$(git ls-files --others --exclude-standard 2>/dev/null)

        if [ -n "$MODIFIED" ] || [ -n "$STAGED" ] || [ -n "$UNTRACKED" ]; then
          [ -z "$(git diff --cached --name-only)" ] && git add . 2>/dev/null

          FILES=$(git diff --cached --name-only)
          FILE_COUNT=$(echo "$FILES" | wc -l | tr -d ' ')
          gum style --foreground {{.MUTED}} "│  $FILE_COUNT fichier(s) à commiter"

          DIFF=$(git diff --cached --no-color | head -c 4000)
          SCOPE=$(echo "$FILES" | python3 {{.ROOT_DIR}}/scripts/taskutil.py field --head 1 --delimiter "/" --index 0 --lowercase)
          AI_LANG="${AI_LANG:-{{.AI_LANG}}}"

          # Construire le prompt via taskutil.py
          PROMPT=$(python3 {{.ROOT_DIR}}/scripts/taskutil.py prompt \
            --template "{{.ROOT_DIR}}/prompts/${AI_LANG}/commit-yolo.txt" \
            --files "$FILES" \
            --scope "$SCOPE" \
            --diff "$DIFF")

          # Appel IA
          if [ "{{.AI_PROVIDER}}" = "claude" ]; then
            RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
          else
            RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
          fi

          # Extraire commit message via taskutil.py
          COMMIT_MSG=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
            --pattern conventional-commit \
            --fallback "chore($SCOPE): update files")

          gum style --foreground {{.MUTED}} "│  Message: $COMMIT_MSG"
          git commit -m "$COMMIT_MSG" >/dev/null 2>&1
          COMMIT_SHA=$(git rev-parse --short HEAD)
          git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1
          gum style --foreground {{.SUCCESS}} "├─  Commit + Push OK ($COMMIT_SHA)"
        else
          gum style --foreground {{.SUCCESS}} "├─  Rien à commiter"
        fi
        echo ""

        # ETAPE 2: PULL REQUEST
        gum style --foreground {{.PRIMARY}} "├─ ETAPE 2/3: PULL REQUEST"

        EXISTING_PR=$(gh pr list --head "$CURRENT_BRANCH" --state open --json number,url --jq '.[0]' 2>/dev/null)

        if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
          PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
          PR_URL=$(echo "$EXISTING_PR" | jq -r '.url')
          gum style --foreground {{.WARNING}} "│  PR #$PR_NUMBER existe déjà"
          gum style --foreground {{.SUCCESS}} "├─  $PR_URL"
        else
          COMMITS_FULL=$(git log "$BASE_BRANCH..$CURRENT_BRANCH" --pretty=format:"%s%n%b" 2>/dev/null | head -c 3000)
          FILES_CHANGED=$(git diff "$BASE_BRANCH..$CURRENT_BRANCH" --name-only 2>/dev/null)
          DIFF_STAT=$(git diff "$BASE_BRANCH..$CURRENT_BRANCH" --stat 2>/dev/null | tail -5)
          AI_LANG="${AI_LANG:-{{.AI_LANG}}}"

          # Construire le prompt via taskutil.py
          PROMPT=$(python3 {{.ROOT_DIR}}/scripts/taskutil.py prompt \
            --template "{{.ROOT_DIR}}/prompts/${AI_LANG}/pr.txt" \
            --files "$FILES_CHANGED" \
            --commits "$COMMITS_FULL" \
            --stats "$DIFF_STAT")

          # Appel IA
          if [ "{{.AI_PROVIDER}}" = "claude" ]; then
            RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
          else
            RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
          fi

          # Extraire titre et body via taskutil.py
          PR_TITLE=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
            --pattern pr-title \
            --fallback "feat($CURRENT_BRANCH): merge to $BASE_BRANCH")
          PR_BODY=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
            --pattern pr-body \
            --fallback "Auto-generated PR from branch $CURRENT_BRANCH")

          gum style --foreground {{.MUTED}} "│  Titre: $PR_TITLE"

          PR_OUTPUT=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE_BRANCH" 2>&1)

          if [ $? -eq 0 ]; then
            PR_NUMBER=$(echo "$PR_OUTPUT" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract --pattern pr-number)
            gum style --foreground {{.SUCCESS}} "├─  PR #$PR_NUMBER créée: $PR_OUTPUT"
          else
            gum style --foreground {{.ERROR}} "├─  Erreur: $PR_OUTPUT"
            exit 1
          fi
        fi
        echo ""

        # ETAPE 3: MERGE
        gum style --foreground {{.PRIMARY}} "├─ ETAPE 3/3: MERGE"
        gum style --foreground {{.MUTED}} "│  Lancement du merge interactif..."
        gum style --foreground {{.MUTED}} "├─"
        echo ""

        task ai:git:merge

        echo ""
        gum style --foreground {{.PRIMARY}} --bold -- "--- PROCHAINES ETAPES ---"
        echo ""

        # Afficher les derniers tags
        LAST_TAGS=$(git tag --sort=-version:refname 2>/dev/null | head -3)
        if [ -n "$LAST_TAGS" ]; then
          gum style --foreground {{.MUTED}} " 3 dernières releases:"
          echo "$LAST_TAGS" | while read tag; do
            TAG_DATE=$(git log -1 --format="%ci" "$tag" 2>/dev/null | cut -d' ' -f1)
            echo "    $(gum style --foreground {{.SUCCESS}} "$tag")  $(gum style --foreground {{.MUTED}} "($TAG_DATE)")"
          done
          echo ""
        fi

        gum style --foreground {{.MUTED}} "Pour créer un nouveau tag"
        gum style --border rounded --border-foreground {{.PRIMARY}} --padding "0 2" --margin "0 2" --foreground {{.SUCCESS}} --bold 'task ai:git:tag'
        echo ""

  # --------------------------------------------------------------------------
  # MENU PRINCIPAL (INTERNAL)
  # --------------------------------------------------------------------------

  menu:
    internal: true
    desc: "Menu IA"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        gum style \
          --foreground {{.SECONDARY}} \
          --border-foreground {{.SECONDARY}} \
          --border rounded \
          --align center \
          --width 45 \
          --padding "0 2" \
          'Intelligence Artificielle' \
          'Provider: {{.AI_PROVIDER}} | Model: {{.AI_MODEL}}'
      - |
        CHOICE=$(gum choose \
          --cursor.foreground="{{.SECONDARY}}" \
          --header="Outils IA" \
          "commit     - Générer un message de commit" \
          "tag        - Créer un tag versionné (semver)" \
          "review     - Review du code (staged)" \
          "explain    - Expliquer du code" \
          "docs       - Générer de la documentation" \
          "test       - Générer des tests" \
          "config     - Configuration IA" \
          "back       - Retour")

        case "$CHOICE" in
          *commit*) task ai:git:commit ;;
          *tag*) task ai:git:tag ;;
          *review*) task ai:review ;;
          *explain*) task ai:explain ;;
          *docs*) task ai:docs ;;
          *test*) task ai:test ;;
          *config*) task ai:config ;;
          *back*) task default ;;
        esac

  # --------------------------------------------------------------------------
  # HELLO (TEST)
  # --------------------------------------------------------------------------

  hello:
    desc: "Test du systeme Claude CLI"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} "Test Claude CLI ({{.AI_PROVIDER}}/{{.AI_MODEL}})..."
        echo ""

        # Charger le prompt depuis fichier externe
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"
        PROMPT_FILE="{{.ROOT_DIR}}/prompts/${AI_LANG}/hello.txt"
        [ ! -f "$PROMPT_FILE" ] && PROMPT_FILE="{{.ROOT_DIR}}/prompts/en/hello.txt"

        if [ ! -f "$PROMPT_FILE" ]; then
          gum style --foreground {{.ERROR}} " Prompt non trouve: $PROMPT_FILE"
          exit 1
        fi

        gum style --foreground {{.MUTED}} "Provider: {{.AI_PROVIDER}}"
        gum style --foreground {{.MUTED}} "Model: {{.AI_MODEL}}"
        gum style --foreground {{.MUTED}} "Lang: $AI_LANG"
        echo ""

        PROJECT_NAME=$(basename "$(pwd)")
        TEMPLATE=$(cat "$PROMPT_FILE")
        PROMPT=$(echo "$TEMPLATE" | sed "s|__PROJECT__|$PROJECT_NAME|g")

        gum spin --spinner dot --title "Appel IA..." -- sleep 1

        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de reponse de l'IA"
          exit 1
        fi

        echo ""
        gum style \
          --foreground {{.SUCCESS}} \
          --border-foreground {{.SUCCESS}} \
          --border rounded \
          --padding "1 2" \
          "$RESPONSE"
        echo ""
        gum style --foreground {{.SUCCESS}} " {{.AI_PROVIDER}}/{{.AI_MODEL}} OK!"

  # --------------------------------------------------------------------------
  # COMMIT INTERACTIF
  # --------------------------------------------------------------------------

  commit:
    internal: true
    desc: "Générer un message de commit avec l'IA"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        # Vérifier s'il y a des changements staged
        if [ -z "$(git diff --cached --name-only)" ]; then
          # Vérifier s'il y a des changements (modifiés ou nouveaux)
          MODIFIED=$(git diff --name-only)
          UNTRACKED=$(git ls-files --others --exclude-standard)

          if [ -n "$MODIFIED" ] || [ -n "$UNTRACKED" ]; then
            gum style --foreground {{.WARNING}} "  Aucun fichier staged"
            echo ""
            if [ -n "$MODIFIED" ]; then
              gum style --foreground {{.MUTED}} "Fichiers modifiés:"
              echo "$MODIFIED" | while read f; do echo "  • $f"; done
            fi
            if [ -n "$UNTRACKED" ]; then
              gum style --foreground {{.MUTED}} "Nouveaux fichiers:"
              echo "$UNTRACKED" | while read f; do echo "  • $f"; done
            fi
            echo ""
            if gum confirm "Ajouter tous les fichiers ?"; then
              git add .
              gum style --foreground {{.SUCCESS}} " Fichiers ajoutés"
            else
              gum style --foreground {{.MUTED}} "Annulé. Lance: git add <fichiers>"
              exit 1
            fi
          else
            gum style --foreground {{.WARNING}} "  Aucun changement à commiter"
            exit 1
          fi
        fi

        gum style --foreground {{.PRIMARY}} "Génération du message de commit ({{.AI_PROVIDER}}/{{.AI_MODEL}})..."
        echo ""

        # Récupérer le diff et contexte
        DIFF=$(git diff --cached --no-color)
        FILES=$(git diff --cached --name-only)
        RECENT_COMMITS=$(git log --oneline -5 2>/dev/null || echo "")

        # Limiter la taille du diff (max 4000 chars)
        DIFF_LIMITED=$(echo "$DIFF" | head -c 4000)

        # Construire le prompt via taskutil.py
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"

        gum spin --spinner dot --title "Analyse en cours..." -- sleep 1

        PROMPT=$(python3 {{.ROOT_DIR}}/scripts/taskutil.py prompt \
          --template "{{.ROOT_DIR}}/prompts/${AI_LANG}/commit.txt" \
          --files "$FILES" \
          --commits "$RECENT_COMMITS" \
          --diff "$DIFF_LIMITED")

        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        # Extraire commit message via taskutil.py
        RESPONSE=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
          --pattern first-line --fallback "")

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de réponse de l'IA"
          exit 1
        fi

        # Nettoyer la réponse
        COMMIT_MSG=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py clean \
          --strip-quotes --trim --collapse-newlines --max-lines 10)

        echo ""
        gum style \
          --foreground {{.SUCCESS}} \
          --border-foreground {{.MUTED}} \
          --border rounded \
          --padding "0 2" \
          "Message suggéré:" \
          "$COMMIT_MSG"
        echo ""

        # Options
        CHOICE=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          " Utiliser ce message" \
          " Modifier le message" \
          " Régénérer" \
          " Annuler")

        case "$CHOICE" in
          *Utiliser*)
            git commit -m "$COMMIT_MSG"
            gum style --foreground {{.SUCCESS}} " Commit créé!"
            ;;
          *Modifier*)
            EDITED=$(gum input --value "$COMMIT_MSG" --width 72 --prompt "Message: ")
            if [ -n "$EDITED" ]; then
              git commit -m "$EDITED"
              gum style --foreground {{.SUCCESS}} " Commit créé!"
            fi
            ;;
          *Régénérer*)
            task ai:commit
            ;;
          *)
            gum style --foreground {{.MUTED}} " Annulé"
            ;;
        esac

  # --------------------------------------------------------------------------
  # GIT:COMMIT (PUBLIC)
  # --------------------------------------------------------------------------

  git:commit:
    desc: "Commit YOLO - auto add + commit + push sans confirmation"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        # 1. Auto-add si rien staged
        [ -z "$(git diff --cached --name-only)" ] && git add . 2>/dev/null

        FILES=$(git diff --cached --name-only)
        [ -z "$FILES" ] && { gum style --foreground {{.WARNING}} " Rien à commiter"; exit 0; }

        FILE_COUNT=$(echo "$FILES" | wc -l | tr -d ' ')
        SCOPE=$(echo "$FILES" | python3 {{.ROOT_DIR}}/scripts/taskutil.py field --head 1 --delimiter "/" --index 0 --lowercase)

        # 2. Afficher box avec fichiers
        FILES_LIST=$(echo "$FILES" | python3 {{.ROOT_DIR}}/scripts/taskutil.py list --prefix "  • ")
        gum style \
          --border rounded \
          --border-foreground {{.PRIMARY}} \
          --padding "0 1" \
          --margin "0" \
          " Commit YOLO ({{.AI_PROVIDER}}/{{.AI_MODEL}})" \
          "" \
          "$FILE_COUNT fichier(s):" \
          "$FILES_LIST"
        echo ""

        # 3. Préparer contexte et prompt via taskutil.py
        DIFF=$(git diff --cached --no-color | head -c 4000)
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"

        PROMPT=$(python3 {{.ROOT_DIR}}/scripts/taskutil.py prompt \
          --template "{{.ROOT_DIR}}/prompts/${AI_LANG}/commit-yolo.txt" \
          --files "$FILES" \
          --scope "$SCOPE" \
          --diff "$DIFF")

        # 4. Appel IA selon provider
        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        # 5. Extraire commit message via taskutil.py
        COMMIT_MSG=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
          --pattern conventional-commit \
          --fallback "chore($SCOPE): update files")

        # 6. Commit + Push
        gum style --foreground {{.SUCCESS}} " $COMMIT_MSG"
        git commit -m "$COMMIT_MSG" >/dev/null 2>&1
        COMMIT_SHA=$(git rev-parse --short HEAD)

        CURRENT_BRANCH=$(git branch --show-current)
        if git push -u origin "$CURRENT_BRANCH" >/dev/null 2>&1; then
          gum style --foreground {{.SUCCESS}} " Push OK → origin/$CURRENT_BRANCH ($COMMIT_SHA)"
        else
          gum style --foreground {{.WARNING}} " Push échoué (commit local: $COMMIT_SHA)"
        fi

  # --------------------------------------------------------------------------
  # GIT:PR (PUBLIC)
  # --------------------------------------------------------------------------

  git:pr:
    desc: "Créer une Pull Request avec titre/body générés par IA"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        # Vérifier que gh est installé
        if ! command -v gh &>/dev/null; then
          gum style --foreground {{.ERROR}} " GitHub CLI (gh) non installé"
          gum style --foreground {{.MUTED}} "   Installe-le: brew install gh"
          exit 1
        fi

        # Vérifier l'authentification gh
        if ! gh auth status &>/dev/null; then
          gum style --foreground {{.ERROR}} " GitHub CLI non authentifié"
          gum style --foreground {{.MUTED}} "   Lance: gh auth login"
          exit 1
        fi

        # Récupérer la branche actuelle
        CURRENT_BRANCH=$(git branch --show-current)

        # Détecter la branche principale (main ou master)
        if git show-ref --verify --quiet refs/heads/main; then
          BASE_BRANCH="main"
        elif git show-ref --verify --quiet refs/heads/master; then
          BASE_BRANCH="master"
        else
          BASE_BRANCH="main"
        fi

        # Vérifier qu'on n'est pas sur la branche principale
        if [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
          gum style --foreground {{.WARNING}} " Tu es sur $BASE_BRANCH, crée d'abord une branche feature"
          exit 0
        fi

        # Vérifier s'il y a des changements non commités
        MODIFIED=$(git diff --name-only 2>/dev/null)
        STAGED=$(git diff --cached --name-only 2>/dev/null)
        UNTRACKED=$(git ls-files --others --exclude-standard 2>/dev/null)

        if [ -n "$MODIFIED" ] || [ -n "$STAGED" ] || [ -n "$UNTRACKED" ]; then
          gum style --foreground {{.WARNING}} "  Changements non commités détectés"
          echo ""
          [ -n "$MODIFIED" ] && echo "$MODIFIED" | while read f; do gum style --foreground {{.MUTED}} "  M $f"; done
          [ -n "$STAGED" ] && echo "$STAGED" | while read f; do gum style --foreground {{.SUCCESS}} "  S $f"; done
          [ -n "$UNTRACKED" ] && echo "$UNTRACKED" | while read f; do gum style --foreground {{.WARNING}} "  ? $f"; done
          echo ""
          gum style --foreground {{.PRIMARY}} "Lancement de ai:git:commit pour commiter les changements..."
          echo ""
          task ai:git:commit
          echo ""
        fi

        gum style --foreground {{.PRIMARY}} "Création de Pull Request ({{.AI_PROVIDER}}/{{.AI_MODEL}})"
        gum style --foreground {{.MUTED}} "Branche: $CURRENT_BRANCH → $BASE_BRANCH"
        echo ""

        # Vérifier s'il y a des commits non pushés
        UNPUSHED=$(git log origin/$CURRENT_BRANCH..$CURRENT_BRANCH --oneline 2>/dev/null | wc -l | tr -d ' ')
        if [ "$UNPUSHED" -gt 0 ]; then
          gum style --foreground {{.WARNING}} "  $UNPUSHED commit(s) non pushé(s)"
          if gum confirm "Pusher avant de créer la PR?"; then
            gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git push -u origin $CURRENT_BRANCH"
            git push -u origin $CURRENT_BRANCH
            gum style --foreground {{.SUCCESS}} " Push effectué"
          fi
        fi

        # Récupérer les commits de la branche
        COMMITS=$(git log $BASE_BRANCH..$CURRENT_BRANCH --oneline 2>/dev/null || git log -10 --oneline)
        COMMITS_FULL=$(git log $BASE_BRANCH..$CURRENT_BRANCH --pretty=format:"%s%n%b" 2>/dev/null | head -c 3000)
        FILES_CHANGED=$(git diff $BASE_BRANCH..$CURRENT_BRANCH --name-only 2>/dev/null || git diff --name-only)
        DIFF_STAT=$(git diff $BASE_BRANCH..$CURRENT_BRANCH --stat 2>/dev/null | tail -5)

        gum style --foreground {{.MUTED}} "Commits à inclure:"
        echo "$COMMITS" | head -10 | while read c; do echo "  • $c"; done
        echo ""

        gum style --foreground {{.PRIMARY}} "Génération du titre et description..."
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"

        # Construire le prompt via taskutil.py
        PROMPT=$(python3 {{.ROOT_DIR}}/scripts/taskutil.py prompt \
          --template "{{.ROOT_DIR}}/prompts/${AI_LANG}/pr.txt" \
          --files "$FILES_CHANGED" \
          --commits "$COMMITS_FULL" \
          --stats "$DIFF_STAT")

        # Appel IA selon provider
        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de réponse de l'IA"
          exit 1
        fi

        # Extraire titre et body via taskutil.py
        PR_TITLE=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
          --pattern pr-title \
          --fallback "feat($CURRENT_BRANCH): $(echo "$COMMITS" | head -1 | cut -d' ' -f2-)")
        PR_BODY=$(echo "$RESPONSE" | python3 {{.ROOT_DIR}}/scripts/taskutil.py extract \
          --pattern pr-body \
          --fallback "$RESPONSE")

        # Afficher le résultat
        echo ""
        gum style --foreground {{.SUCCESS}} "Titre:"
        gum style --border rounded --border-foreground {{.MUTED}} --padding "0 1" --margin "0 2" "$PR_TITLE"
        echo ""
        gum style --foreground {{.SUCCESS}} "Description:"
        echo "$PR_BODY" | head -30
        echo ""

        # Options
        CHOICE=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          " Créer la PR" \
          " Modifier le titre" \
          " Régénérer" \
          " Créer en draft" \
          " Annuler")

        case "$CHOICE" in
          *"Créer la PR"*)
            gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ gh pr create --title \"$PR_TITLE\" --base $BASE_BRANCH"
            PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE_BRANCH" 2>&1)
            if [ $? -eq 0 ]; then
              gum style --foreground {{.SUCCESS}} " PR créée!"
              gum style --foreground {{.PRIMARY}} "$PR_URL"
            else
              gum style --foreground {{.ERROR}} " Erreur: $PR_URL"
            fi
            ;;
          *"Modifier"*)
            PR_TITLE=$(gum input --value "$PR_TITLE" --width 72 --prompt "Titre: ")
            if [ -n "$PR_TITLE" ]; then
              gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ gh pr create --title \"$PR_TITLE\" --base $BASE_BRANCH"
              PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE_BRANCH" 2>&1)
              if [ $? -eq 0 ]; then
                gum style --foreground {{.SUCCESS}} " PR créée!"
                gum style --foreground {{.PRIMARY}} "$PR_URL"
              fi
            fi
            ;;
          *"Régénérer"*)
            task ai:git:pr
            ;;
          *"draft"*)
            gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ gh pr create --title \"$PR_TITLE\" --base $BASE_BRANCH --draft"
            PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE_BRANCH" --draft 2>&1)
            if [ $? -eq 0 ]; then
              gum style --foreground {{.SUCCESS}} " PR draft créée!"
              gum style --foreground {{.PRIMARY}} "$PR_URL"
            fi
            ;;
          *)
            gum style --foreground {{.MUTED}} " Annulé"
            ;;
        esac

  # --------------------------------------------------------------------------
  # GIT:MERGE (PUBLIC)
  # --------------------------------------------------------------------------

  git:merge:
    desc: "Merger une Pull Request sur main/master"
    deps: [_check-tools]
    cmds:
      - |
        # Vérifier que gh est installé
        if ! command -v gh &>/dev/null; then
          gum style --foreground {{.ERROR}} " GitHub CLI (gh) non installé"
          exit 1
        fi

        # SÉCURITÉ: Vérifier qu'il n'y a pas de changements locaux non synchronisés
        MODIFIED=$(git diff --name-only 2>/dev/null)
        STAGED=$(git diff --cached --name-only 2>/dev/null)
        UNTRACKED=$(git ls-files --others --exclude-standard 2>/dev/null)

        if [ -n "$MODIFIED" ] || [ -n "$STAGED" ] || [ -n "$UNTRACKED" ]; then
          gum style --foreground {{.ERROR}} " STOP: Changements non commités détectés!"
          echo ""
          [ -n "$MODIFIED" ] && echo "$MODIFIED" | while read f; do gum style --foreground {{.MUTED}} "  M $f"; done
          [ -n "$STAGED" ] && echo "$STAGED" | while read f; do gum style --foreground {{.SUCCESS}} "  S $f"; done
          [ -n "$UNTRACKED" ] && echo "$UNTRACKED" | while read f; do gum style --foreground {{.WARNING}} "  ? $f"; done
          echo ""
          gum style --foreground {{.WARNING}} "  Tu dois d'abord commiter ces changements avant de merger"
          if gum confirm "Lancer task ai:git:commit maintenant?"; then
            task ai:git:commit
            echo ""
          else
            gum style --foreground {{.ERROR}} "Merge annulé - commit d'abord tes changements"
            exit 1
          fi
        fi

        # SÉCURITÉ: Vérifier les commits non pushés sur la branche courante
        CURRENT_BRANCH=$(git branch --show-current)
        UNPUSHED=$(git log origin/$CURRENT_BRANCH..$CURRENT_BRANCH --oneline 2>/dev/null | wc -l | tr -d ' ')

        if [ "$UNPUSHED" -gt 0 ]; then
          gum style --foreground {{.ERROR}} " STOP: $UNPUSHED commit(s) non pushé(s) sur $CURRENT_BRANCH!"
          echo ""
          git log origin/$CURRENT_BRANCH..$CURRENT_BRANCH --oneline | while read c; do
            gum style --foreground {{.MUTED}} "  • $c"
          done
          echo ""
          if gum confirm "Pusher maintenant?"; then
            gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git push origin $CURRENT_BRANCH"
            git push origin $CURRENT_BRANCH
            gum style --foreground {{.SUCCESS}} " Push effectué"
            echo ""
          else
            gum style --foreground {{.ERROR}} "Merge annulé - push d'abord tes commits"
            exit 1
          fi
        fi

        gum style --foreground {{.PRIMARY}} "Merge de Pull Request"
        echo ""

        # Lister les PRs ouvertes
        PRS=$(gh pr list --state open --json number,title,headRefName,author --jq '.[] | "\(.number)\t\(.title)\t\(.headRefName)\t\(.author.login)"' 2>/dev/null)

        if [ -z "$PRS" ]; then
          gum style --foreground {{.WARNING}} "  Aucune PR ouverte"
          exit 0
        fi

        gum style --foreground {{.MUTED}} "PRs ouvertes:"
        echo ""

        # Construire le menu
        OPTIONS=""
        while IFS=$'\t' read -r num title branch author; do
          OPTIONS="$OPTIONS#$num - $title ($branch by @$author)"
        done <<< "$PRS"

        # Sélectionner une PR
        SELECTED=$(echo "$OPTIONS" | tr '#' '\n' | grep -v '^$' | gum choose --cursor.foreground="{{.PRIMARY}}" --header="Sélectionne une PR à merger:")

        if [ -z "$SELECTED" ]; then
          gum style --foreground {{.MUTED}} " Annulé"
          exit 0
        fi

        PR_NUMBER=$(echo "$SELECTED" | cut -d' ' -f1)

        # Afficher les détails
        echo ""
        gum style --foreground {{.PRIMARY}} "Détails de la PR #$PR_NUMBER:"
        GH_PAGER=cat gh pr view "$PR_NUMBER" --json title,body,commits,changedFiles --jq '"Titre: \(.title)\nCommits: \(.commits | length)\nFichiers modifiés: \(.changedFiles)"'
        echo ""

        # Vérifier le statut des checks (CI, CodeRabbit, etc.)
        gum style --foreground {{.PRIMARY}} "Statut des checks:"
        CHECKS_JSON=$(gh pr checks "$PR_NUMBER" --json name,state,conclusion 2>/dev/null || echo "[]")

        if [ "$CHECKS_JSON" = "[]" ] || [ -z "$CHECKS_JSON" ]; then
          gum style --foreground {{.MUTED}} "  Aucun check configuré"
        else
          # Compter les statuts
          PENDING=$(echo "$CHECKS_JSON" | jq '[.[] | select(.state == "PENDING" or .state == "IN_PROGRESS")] | length')
          SUCCESS=$(echo "$CHECKS_JSON" | jq '[.[] | select(.conclusion == "SUCCESS")] | length')
          FAILURE=$(echo "$CHECKS_JSON" | jq '[.[] | select(.conclusion == "FAILURE")] | length')
          TOTAL=$(echo "$CHECKS_JSON" | jq 'length')

          # Afficher chaque check
          echo "$CHECKS_JSON" | jq -r '.[] | "\(.state)\t\(.conclusion // "—")\t\(.name)"' | while IFS=$'\t' read -r state conclusion name; do
            if [ "$state" = "PENDING" ] || [ "$state" = "IN_PROGRESS" ]; then
              gum style --foreground {{.WARNING}} "   $name (en cours...)"
            elif [ "$conclusion" = "SUCCESS" ]; then
              gum style --foreground {{.SUCCESS}} "   $name"
            elif [ "$conclusion" = "FAILURE" ]; then
              gum style --foreground {{.ERROR}} "   $name"
            else
              gum style --foreground {{.MUTED}} "  ⚪ $name ($conclusion)"
            fi
          done
          echo ""

          # Si des checks sont en cours, proposer d'attendre
          if [ "$PENDING" -gt 0 ]; then
            gum style --foreground {{.WARNING}} "  $PENDING check(s) en cours d'exécution"
            echo ""
            WAIT_CHOICE=$(gum choose \
              --cursor.foreground="{{.PRIMARY}}" \
              --header="Que faire?" \
              " Attendre la fin des checks" \
              " Rafraîchir le statut" \
              " Merger quand même (non recommandé)" \
              " Annuler")

            case "$WAIT_CHOICE" in
              *"Attendre"*)
                gum style --foreground {{.PRIMARY}} "Attente de la fin des checks..."
                gum spin --spinner dot --title "Checks en cours..." -- gh pr checks "$PR_NUMBER" --watch
                echo ""
                gum style --foreground {{.SUCCESS}} " Checks terminés!"
                # Re-vérifier le statut
                CHECKS_JSON=$(gh pr checks "$PR_NUMBER" --json name,state,conclusion 2>/dev/null)
                FAILURE=$(echo "$CHECKS_JSON" | jq '[.[] | select(.conclusion == "FAILURE")] | length')
                if [ "$FAILURE" -gt 0 ]; then
                  gum style --foreground {{.ERROR}} " $FAILURE check(s) ont échoué!"
                  if ! gum confirm --default=false "Merger malgré les échecs?"; then
                    exit 0
                  fi
                fi
                ;;
              *"Rafraîchir"*)
                exec task ai:git:merge
                ;;
              *"Merger quand même"*)
                gum style --foreground {{.WARNING}} "  Merge forcé sans attendre les checks"
                ;;
              *)
                gum style --foreground {{.MUTED}} " Annulé"
                exit 0
                ;;
            esac
          fi

          # Si des checks ont échoué, avertir
          if [ "$FAILURE" -gt 0 ]; then
            gum style --foreground {{.ERROR}} " $FAILURE check(s) ont échoué!"
            if ! gum confirm --default=false "Merger malgré les échecs?"; then
              gum style --foreground {{.MUTED}} " Annulé"
              exit 0
            fi
          fi
        fi
        echo ""

        # Choisir la stratégie de merge
        STRATEGY=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          --header="Stratégie de merge:" \
          "squash - Combiner tous les commits en un seul (recommandé)" \
          "merge  - Merge commit classique" \
          "rebase - Rebase les commits sur la branche cible")

        MERGE_FLAG=""
        case "$STRATEGY" in
          squash*) MERGE_FLAG="--squash" ;;
          merge*) MERGE_FLAG="--merge" ;;
          rebase*) MERGE_FLAG="--rebase" ;;
        esac

        # Confirmation
        echo ""
        if ! gum confirm "Merger la PR #$PR_NUMBER avec $MERGE_FLAG ?"; then
          gum style --foreground {{.MUTED}} " Annulé"
          exit 0
        fi

        # Merge
        gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ gh pr merge $PR_NUMBER $MERGE_FLAG"
        gum spin --spinner dot --title "Merge en cours..." -- gh pr merge "$PR_NUMBER" $MERGE_FLAG

        if [ $? -eq 0 ]; then
          gum style --foreground {{.SUCCESS}} " PR #$PR_NUMBER mergée!"

          # Proposer de supprimer la branche
          echo ""
          if gum confirm --default=false "Supprimer la branche locale et remote?"; then
            gh pr view "$PR_NUMBER" --json headRefName --jq '.headRefName' | xargs -I {} bash -c 'git branch -d {} 2>/dev/null; git push origin --delete {} 2>/dev/null'
            gum style --foreground {{.SUCCESS}} " Branche supprimée"
          fi

          # Mettre à jour la branche locale
          echo ""
          gum style --foreground {{.PRIMARY}} "Mise à jour de la branche principale..."
          if git checkout main 2>/dev/null; then
            TARGET_BRANCH="main"
          else
            git checkout master 2>/dev/null
            TARGET_BRANCH="master"
          fi
          gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git pull origin $TARGET_BRANCH"
          git pull origin "$TARGET_BRANCH"
          gum style --foreground {{.SUCCESS}} " Branche principale à jour"
        else
          gum style --foreground {{.ERROR}} " Erreur lors du merge"
        fi

  # --------------------------------------------------------------------------
  # CODE REVIEW
  # --------------------------------------------------------------------------

  review:
    desc: "Review du code avec l'IA (staged ou unstaged)"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        # Déterminer quoi reviewer
        if [ -n "$(git diff --cached --name-only)" ]; then
          DIFF=$(git diff --cached --no-color)
          SCOPE="staged"
        elif [ -n "$(git diff --name-only)" ]; then
          DIFF=$(git diff --no-color)
          SCOPE="unstaged"
        else
          gum style --foreground {{.WARNING}} "  Aucun changement à reviewer"
          exit 1
        fi

        gum style --foreground {{.PRIMARY}} "Review du code ($SCOPE) - {{.AI_PROVIDER}}/{{.AI_MODEL}}..."
        echo ""

        DIFF_LIMITED=$(echo "$DIFF" | head -c 6000)
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"

        gum spin --spinner dot --title "Analyse en cours..." -- sleep 1

        # Construire le prompt via taskutil.py
        PROMPT=$(python3 {{.ROOT_DIR}}/scripts/taskutil.py prompt \
          --template "{{.ROOT_DIR}}/prompts/${AI_LANG}/review.txt" \
          --diff "$DIFF_LIMITED")

        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de réponse de l'IA"
          exit 1
        fi

        echo ""
        echo "$RESPONSE" | gum format
        echo ""

        if gum confirm --default=false "Sauvegarder la review dans un fichier ?"; then
          FILENAME=".task/review-$(date +%Y%m%d-%H%M%S).md"
          mkdir -p .task
          echo "$RESPONSE" > "$FILENAME"
          gum style --foreground {{.SUCCESS}} " Review sauvegardée: $FILENAME"
        fi

  # --------------------------------------------------------------------------
  # EXPLAIN CODE
  # --------------------------------------------------------------------------

  explain:
    desc: "Expliquer du code selectionne"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} "Expliquer du code ({{.AI_PROVIDER}}/{{.AI_MODEL}})"
        echo ""

        FILE=$(gum file --height 15 .)

        if [ -z "$FILE" ] || [ ! -f "$FILE" ]; then
          gum style --foreground {{.ERROR}} " Fichier non sélectionné"
          exit 1
        fi

        gum style --foreground {{.MUTED}} "Fichier: $FILE"
        echo ""

        CODE=$(head -c 4000 "$FILE")

        # Charger le prompt depuis fichier externe
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"
        PROMPT_FILE="{{.ROOT_DIR}}/prompts/${AI_LANG}/explain.txt"
        [ ! -f "$PROMPT_FILE" ] && PROMPT_FILE="{{.ROOT_DIR}}/prompts/en/explain.txt"
        TEMPLATE=$(cat "$PROMPT_FILE" 2>/dev/null || echo "Explain this code: __CODE__")

        gum spin --spinner dot --title "Analyse en cours..." -- sleep 1

        PROMPT=$(echo "$TEMPLATE" | sed "s|__FILE__|$FILE|g")
        PROMPT=$(printf "%s\n\nCODE:\n%s" "$PROMPT" "$CODE")

        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de réponse de l'IA"
          exit 1
        fi

        echo ""
        echo "$RESPONSE" | gum format

  # --------------------------------------------------------------------------
  # GENERATE DOCS
  # --------------------------------------------------------------------------

  docs:
    desc: "Generer de la documentation (JSDoc/README/API)"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} "Générer de la documentation ({{.AI_PROVIDER}}/{{.AI_MODEL}})"
        echo ""

        FILE=$(gum file --height 15 .)

        if [ -z "$FILE" ] || [ ! -f "$FILE" ]; then
          gum style --foreground {{.ERROR}} " Fichier non sélectionné"
          exit 1
        fi

        DOC_TYPE=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          --header="Type de documentation" \
          "JSDoc / TSDoc (commentaires inline)" \
          "README (documentation externe)" \
          "API Documentation")

        CODE=$(head -c 5000 "$FILE")

        # Déterminer le fichier prompt selon le type
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"
        case "$DOC_TYPE" in
          *JSDoc*) PROMPT_NAME="docs-jsdoc" ;;
          *README*) PROMPT_NAME="docs-readme" ;;
          *API*) PROMPT_NAME="docs-api" ;;
        esac

        PROMPT_FILE="{{.ROOT_DIR}}/prompts/${AI_LANG}/${PROMPT_NAME}.txt"
        [ ! -f "$PROMPT_FILE" ] && PROMPT_FILE="{{.ROOT_DIR}}/prompts/en/${PROMPT_NAME}.txt"
        TEMPLATE=$(cat "$PROMPT_FILE" 2>/dev/null || echo "Generate documentation for: __CODE__")

        gum spin --spinner dot --title "Génération de la documentation..." -- sleep 1

        PROMPT=$(echo "$TEMPLATE" | sed "s|__FILE__|$FILE|g")
        PROMPT=$(printf "%s\n\nCODE:\n%s" "$PROMPT" "$CODE")

        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de réponse de l'IA"
          exit 1
        fi

        echo ""
        echo "$RESPONSE" | gum format
        echo ""

        if gum confirm "Sauvegarder la documentation ?"; then
          case "$DOC_TYPE" in
            *JSDoc*)
              case "$FILE" in
                *.ts) OUT_FILE="${FILE%.ts}.documented.ts" ;;
                *.tsx) OUT_FILE="${FILE%.tsx}.documented.tsx" ;;
                *.js) OUT_FILE="${FILE%.js}.documented.js" ;;
                *.jsx) OUT_FILE="${FILE%.jsx}.documented.jsx" ;;
                *) OUT_FILE="${FILE}.documented" ;;
              esac
              ;;
            *)
              OUT_FILE=".task/docs-$(basename "$FILE")-$(date +%Y%m%d).md"
              mkdir -p .task
              ;;
          esac
          echo "$RESPONSE" > "$OUT_FILE"
          gum style --foreground {{.SUCCESS}} " Sauvegardé: $OUT_FILE"
        fi

  # --------------------------------------------------------------------------
  # GENERATE TESTS
  # --------------------------------------------------------------------------

  test:
    desc: "Generer des tests (Vitest/Jest/Playwright)"
    deps: [_check-tools, _check-ai]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} "Générer des tests ({{.AI_PROVIDER}}/{{.AI_MODEL}})"
        echo ""

        FILE=$(gum file --height 15 .)

        if [ -z "$FILE" ] || [ ! -f "$FILE" ]; then
          gum style --foreground {{.ERROR}} " Fichier non sélectionné"
          exit 1
        fi

        FRAMEWORK=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          --header="Framework de test" \
          "Vitest" \
          "Jest" \
          "Playwright (E2E)" \
          "Testing Library")

        CODE=$(head -c 4000 "$FILE")

        # Charger le prompt depuis fichier externe
        AI_LANG="${AI_LANG:-{{.AI_LANG}}}"
        PROMPT_FILE="{{.ROOT_DIR}}/prompts/${AI_LANG}/test.txt"
        [ ! -f "$PROMPT_FILE" ] && PROMPT_FILE="{{.ROOT_DIR}}/prompts/en/test.txt"
        TEMPLATE=$(cat "$PROMPT_FILE" 2>/dev/null || echo "Generate tests for: __CODE__")

        gum spin --spinner dot --title "Génération des tests..." -- sleep 1

        PROMPT=$(echo "$TEMPLATE" | sed "s|__FILE__|$FILE|g" | sed "s|__FRAMEWORK__|$FRAMEWORK|g")
        PROMPT=$(printf "%s\n\nCODE:\n%s" "$PROMPT" "$CODE")

        if [ "{{.AI_PROVIDER}}" = "claude" ]; then
          RESPONSE=$(claude -p "$PROMPT" --model {{.AI_MODEL}} 2>/dev/null || true)
        else
          RESPONSE=$(echo "$PROMPT" | ollama run {{.AI_MODEL}} 2>/dev/null || true)
        fi

        if [ -z "$RESPONSE" ]; then
          gum style --foreground {{.ERROR}} " Pas de réponse de l'IA"
          exit 1
        fi

        echo ""
        echo "$RESPONSE" | gum format
        echo ""

        if gum confirm "Sauvegarder les tests ?"; then
          BASE=$(basename "$FILE" | sed 's/\.[^.]*$//')
          OUT_FILE="__tests__/${BASE}.test.ts"
          mkdir -p __tests__

          echo "$RESPONSE" | sed -n '/```typescript\|```ts\|```javascript\|```js/,/```/p' | sed '1d;$d' > "$OUT_FILE" 2>/dev/null

          if [ ! -s "$OUT_FILE" ]; then
            echo "$RESPONSE" > "$OUT_FILE"
          fi

          gum style --foreground {{.SUCCESS}} " Tests sauvegardés: $OUT_FILE"
        fi

  # --------------------------------------------------------------------------
  # CONFIGURATION
  # --------------------------------------------------------------------------

  config:
    desc: "Afficher la configuration IA"
    deps: [_check-tools]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} "Configuration IA actuelle"
        echo ""
        echo "Provider:      {{.AI_PROVIDER}}"
        echo "Model:         {{.AI_MODEL}}"
        echo "Language:      {{.AI_LANG}}"
        echo ""

        gum style --foreground {{.MUTED}} "Pour modifier, exporte les variables:"
        echo ""
        gum style --foreground {{.SUCCESS}} "# Claude (défaut)"
        echo "  export AI_PROVIDER=claude"
        echo "  export AI_MODEL=haiku    # ou sonnet, opus"
        echo ""
        gum style --foreground {{.WARNING}} "# Ollama (optionnel)"
        echo "  export AI_PROVIDER=ollama"
        echo "  export AI_MODEL=qwen2.5-coder:14b"
        echo ""

        if [ "{{.AI_PROVIDER}}" != "claude" ]; then
          if gum confirm "Voir les modèles Ollama disponibles ?"; then
            echo ""
            gum style --foreground {{.PRIMARY}} "Modèles installés:"
            ollama list 2>/dev/null | tail -n +2 | awk '{print "  " $1}' || echo "  Impossible de récupérer la liste"
          fi
        fi

  # --------------------------------------------------------------------------
  # PULL MODEL
  # --------------------------------------------------------------------------

  pull:
    desc: "Telecharger un modele Ollama"
    deps: [_check-tools, _check-ollama]
    cmds:
      - |
        gum style --foreground {{.PRIMARY}} "Télécharger un modèle Ollama"
        echo ""

        MODEL=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          --header="Modèle à télécharger" \
          "qwen2.5-coder:14b (recommandé, 9GB)" \
          "qwen2.5-coder:7b (rapide, 4.5GB)" \
          "llama3.2:3b (ultra rapide, 2GB)" \
          "deepseek-coder-v2:16b (code, 10GB)" \
          "mistral:7b (général, 4GB)" \
          "codellama:7b (code, 4GB)" \
          "Autre (saisir le nom)")

        case "$MODEL" in
          *qwen2.5-coder:14b*) MODEL_NAME="qwen2.5-coder:14b" ;;
          *qwen2.5-coder:7b*) MODEL_NAME="qwen2.5-coder:7b" ;;
          *llama3.2:3b*) MODEL_NAME="llama3.2:3b" ;;
          *deepseek*) MODEL_NAME="deepseek-coder-v2:16b" ;;
          *mistral*) MODEL_NAME="mistral:7b" ;;
          *codellama*) MODEL_NAME="codellama:7b" ;;
          *Autre*)
            MODEL_NAME=$(gum input --placeholder "nom:tag" --prompt "Modèle: ")
            ;;
        esac

        if [ -n "$MODEL_NAME" ]; then
          gum style --foreground {{.MUTED}} "Téléchargement de $MODEL_NAME..."
          ollama pull "$MODEL_NAME"
          gum style --foreground {{.SUCCESS}} " Modèle téléchargé: $MODEL_NAME"
        fi

  # --------------------------------------------------------------------------
  # START/STOP OLLAMA
  # --------------------------------------------------------------------------

  start:
    desc: "Demarrer le service Ollama"
    deps: [_check-tools]
    cmds:
      - |
        if ollama list &>/dev/null; then
          gum style --foreground {{.WARNING}} "  Ollama est déjà en cours d'exécution"
          exit 0
        fi

        gum style --foreground {{.PRIMARY}} "Démarrage d'Ollama..."

        nohup ollama serve > /dev/null 2>&1 &

        gum spin --spinner dot --title "Attente du démarrage..." -- sleep 2

        if ollama list &>/dev/null; then
          gum style --foreground {{.SUCCESS}} " Ollama démarré"
        else
          gum style --foreground {{.ERROR}} " Échec du démarrage d'Ollama"
          exit 1
        fi

  stop:
    desc: "Arreter le service Ollama"
    deps: [_check-tools]
    cmds:
      - |
        if ! ollama list &>/dev/null; then
          gum style --foreground {{.WARNING}} "  Ollama n'est pas en cours d'exécution"
          exit 0
        fi

        gum style --foreground {{.PRIMARY}} "Arrêt d'Ollama..."

        OLLAMA_PID=$(pgrep -f "ollama serve" 2>/dev/null || lsof -t -i :11434 2>/dev/null || true)

        if [ -n "$OLLAMA_PID" ]; then
          gum style --foreground {{.MUTED}} "PID trouvé: $OLLAMA_PID"
          kill -TERM $OLLAMA_PID 2>/dev/null || true
          gum spin --spinner dot --title "Arrêt en cours..." -- sleep 2

          if ! ollama list &>/dev/null; then
            gum style --foreground {{.SUCCESS}} " Ollama arrêté"
          else
            kill -KILL $OLLAMA_PID 2>/dev/null || true
            sleep 1
            if ! ollama list &>/dev/null; then
              gum style --foreground {{.SUCCESS}} " Ollama arrêté (force kill)"
            else
              gum style --foreground {{.ERROR}} " Impossible d'arrêter Ollama"
            fi
          fi
        else
          gum style --foreground {{.WARNING}} "  Aucun processus Ollama trouvé"
        fi

  # --------------------------------------------------------------------------
  # GIT:BRANCH (PUBLIC)
  # --------------------------------------------------------------------------

  git:branch:
    desc: "Creer une branche (Conventional Commits) et la pusher sur origin"
    deps: [_check-tools]
    cmds:
      - |
        NAME="{{.CLI_ARGS}}"

        # Vérifier qu'un nom est fourni
        if [ -z "$NAME" ]; then
          gum style --foreground {{.ERROR}} " Usage: task ai:branch -- nom-de-la-branche"
          gum style --foreground {{.MUTED}} "   Exemple: task ai:branch -- add-user-auth"
          exit 1
        fi

        echo ""
        gum style --foreground {{.PRIMARY}} "Création de branche"
        echo ""

        # Menu Conventional Commits
        TYPE=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          --header="Type (Conventional Commits):" \
          "feat     - Nouvelle fonctionnalité" \
          "fix      - Correction de bug" \
          "docs     - Documentation" \
          "style    - Formatage (pas de code)" \
          "refactor - Refactoring" \
          "perf     - Performance" \
          "test     - Tests" \
          "build    - Système de build" \
          "ci       - CI/CD" \
          "chore    - Tâches diverses")

        if [ -z "$TYPE" ]; then
          gum style --foreground {{.MUTED}} " Annulé"
          exit 0
        fi

        # Extraire le type (premier mot)
        TYPE_KEY=$(echo "$TYPE" | awk '{print $1}')

        # Mapper vers les préfixes de branche
        case "$TYPE_KEY" in
          feat)     PREFIX="feature" ;;
          fix)      PREFIX="fix" ;;
          docs)     PREFIX="docs" ;;
          style)    PREFIX="style" ;;
          refactor) PREFIX="refactor" ;;
          perf)     PREFIX="perf" ;;
          test)     PREFIX="test" ;;
          build)    PREFIX="build" ;;
          ci)       PREFIX="ci" ;;
          chore)    PREFIX="chore" ;;
          *)        PREFIX="$TYPE_KEY" ;;
        esac

        BRANCH_NAME="${PREFIX}/${NAME}"

        # Vérifier que la branche n'existe pas déjà
        if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
          gum style --foreground {{.ERROR}} " La branche '$BRANCH_NAME' existe déjà localement"
          exit 1
        fi

        if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
          gum style --foreground {{.ERROR}} " La branche '$BRANCH_NAME' existe déjà sur origin"
          exit 1
        fi

        CURRENT_BRANCH=$(git branch --show-current)
        echo ""
        gum style --foreground {{.MUTED}} "  Branche actuelle: $CURRENT_BRANCH"
        gum style --foreground {{.SUCCESS}} "  Nouvelle branche: $BRANCH_NAME"
        echo ""

        if ! gum confirm "Créer et pusher cette branche?"; then
          gum style --foreground {{.MUTED}} " Annulé"
          exit 0
        fi

        echo ""
        gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git checkout -b $BRANCH_NAME"
        gum spin --spinner dot --title "Création de la branche..." -- git checkout -b "$BRANCH_NAME"
        gum style --foreground {{.SUCCESS}} " Branche '$BRANCH_NAME' créée"

        gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git push -u origin $BRANCH_NAME"
        gum spin --spinner dot --title "Push vers origin..." -- git push -u origin "$BRANCH_NAME"
        gum style --foreground {{.SUCCESS}} " Branche pushée sur origin"

        echo ""
        gum style --foreground {{.PRIMARY}} "Tu es maintenant sur: $BRANCH_NAME"

  # --------------------------------------------------------------------------
  # GIT:TAG (PUBLIC)
  # --------------------------------------------------------------------------

  git:tag:
    desc: "Creer un tag versionne (semver)"
    deps: [_check-tools]
    cmds:
      - |
        # Construire le contenu de la box
        BOX_CONTENT=""

        # 3 dernières releases
        LAST_TAGS=$(git tag --sort=-version:refname 2>/dev/null | head -3)
        if [ -n "$LAST_TAGS" ]; then
          BOX_CONTENT=" 3 dernières releases:\n"
          while read tag; do
            TAG_DATE=$(git log -1 --format="%ci" "$tag" 2>/dev/null | cut -d' ' -f1)
            BOX_CONTENT="${BOX_CONTENT}    ${tag}  (${TAG_DATE})\n"
          done <<< "$LAST_TAGS"
          BOX_CONTENT="${BOX_CONTENT}\n"
        else
          BOX_CONTENT="  Aucun tag existant\n\n"
        fi

        # Dernier commit
        LAST_COMMIT=$(git log -1 --format="%h %s" 2>/dev/null)
        if [ -n "$LAST_COMMIT" ]; then
          BOX_CONTENT="${BOX_CONTENT}Dernier commit:\n  ${LAST_COMMIT}\n\n"
        fi

        # Récupérer le dernier tag et analyser
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        if [ -z "$LAST_TAG" ]; then
          SUGGESTED_VERSION="0.1.0"
          BOX_CONTENT="${BOX_CONTENT}Suggestion: v${SUGGESTED_VERSION}"
        else
          # Compter les commits depuis le dernier tag
          COMMIT_COUNT=$(git rev-list "$LAST_TAG..HEAD" --count 2>/dev/null || echo "0")
          BOX_CONTENT="${BOX_CONTENT}Dernier tag: ${LAST_TAG}\n"
          BOX_CONTENT="${BOX_CONTENT}Commits depuis: ${COMMIT_COUNT}\n\n"

          # Analyser les commits pour suggérer le type de bump
          COMMITS=$(git log "$LAST_TAG..HEAD" --format="%s" 2>/dev/null)
          FEAT_COUNT=$(echo "$COMMITS" | grep -cE "^feat(\(|:)" 2>/dev/null || echo "0")
          FIX_COUNT=$(echo "$COMMITS" | grep -cE "^fix(\(|:)" 2>/dev/null || echo "0")
          BREAKING=$(echo "$COMMITS" | grep -ciE "BREAKING CHANGE|^[a-z]+(\([^)]*\))?!:" 2>/dev/null || echo "0")

          BOX_CONTENT="${BOX_CONTENT}Analyse des commits:\n"
          BOX_CONTENT="${BOX_CONTENT}  - ${FEAT_COUNT} feat (fonctionnalités)\n"
          BOX_CONTENT="${BOX_CONTENT}  - ${FIX_COUNT} fix (corrections)\n"
          [ "$BREAKING" -gt 0 ] && BOX_CONTENT="${BOX_CONTENT}  - ${BREAKING} BREAKING CHANGE(S)!\n"
          BOX_CONTENT="${BOX_CONTENT}\n"

          # Parser la version actuelle
          VERSION=${LAST_TAG#v}
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          PATCH=$(echo "$VERSION" | cut -d. -f3)

          # Suggérer le bump
          if [ "$BREAKING" -gt 0 ]; then
            BUMP="MAJOR"
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            BUMP="MINOR"
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
          else
            BUMP="PATCH"
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
          fi

          SUGGESTED_VERSION="${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          BOX_CONTENT="${BOX_CONTENT}Suggestion: ${BUMP} bump → v${SUGGESTED_VERSION}"

          # Vérifier si 0 commits
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo ""
            gum style --foreground {{.PRIMARY}} --bold " Création de Tag"
            echo -e "$BOX_CONTENT" | gum style --border rounded --border-foreground {{.PRIMARY}} --padding "1 2" --margin "0 2"
            echo ""
            gum style --foreground {{.WARNING}} "  Aucun commit depuis $LAST_TAG"
            if ! gum confirm "Créer quand même un nouveau tag?"; then
              exit 0
            fi
            echo ""
          fi
        fi

        # Afficher la box avec titre
        echo ""
        gum style --foreground {{.PRIMARY}} --bold " Création de Tag"
        echo -e "$BOX_CONTENT" | gum style --border rounded --border-foreground {{.PRIMARY}} --padding "1 2" --margin "0 2"
        echo ""

        # Menu de choix
        CHOICE=$(gum choose \
          --cursor.foreground="{{.PRIMARY}}" \
          " Utiliser v$SUGGESTED_VERSION" \
          " Modifier la version" \
          " Voir les commits depuis ${LAST_TAG:-le début}" \
          " Annuler")

        case "$CHOICE" in
          *"Utiliser"*)
            FINAL_VERSION="v$SUGGESTED_VERSION"
            ;;
          *"Modifier"*)
            VERSION_INPUT=$(gum input --value "$SUGGESTED_VERSION" --placeholder "1.0.0" --prompt "Version : ")
            [ -z "$VERSION_INPUT" ] && { gum style --foreground {{.MUTED}} " Annulé"; exit 0; }
            FINAL_VERSION="v${VERSION_INPUT#v}"
            ;;
          *"Voir"*)
            echo ""
            gum style --foreground {{.PRIMARY}} "Commits depuis ${LAST_TAG:-le début}:"
            echo ""
            if [ -n "$LAST_TAG" ]; then
              git log "$LAST_TAG..HEAD" --oneline | head -20
            else
              git log --oneline | head -20
            fi
            echo ""
            exec task ai:git:tag
            ;;
          *)
            gum style --foreground {{.MUTED}} " Annulé"
            exit 0
            ;;
        esac

        # Valider le format
        if ! echo "$FINAL_VERSION" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+'; then
          gum style --foreground {{.ERROR}} " Format invalide: $FINAL_VERSION"
          gum style --foreground {{.MUTED}} "   Format attendu: 1.0.0, 2.1.3, etc."
          exit 1
        fi

        # Vérifier que le tag n'existe pas déjà
        if git rev-parse "$FINAL_VERSION" >/dev/null 2>&1; then
          gum style --foreground {{.ERROR}} " Le tag $FINAL_VERSION existe déjà!"
          exit 1
        fi

        # Créer le tag
        echo ""
        gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git tag -a $FINAL_VERSION -m \"Release $FINAL_VERSION\""
        git tag -a "$FINAL_VERSION" -m "Release $FINAL_VERSION"
        gum style --foreground {{.SUCCESS}} " Tag $FINAL_VERSION créé!"
        echo ""

        # Push du tag
        gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ git push origin $FINAL_VERSION"
        git push origin "$FINAL_VERSION"
        gum style --foreground {{.SUCCESS}} " Tag pushé sur origin"

        # Créer une release GitHub si gh disponible
        echo ""
        if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
          gum style --foreground {{.PRIMARY}} "Création de la GitHub Release..."

          # Récupérer les commits depuis le dernier tag
          PREV_TAG=$(git describe --tags --abbrev=0 "$FINAL_VERSION^" 2>/dev/null || echo "")
          if [ -n "$PREV_TAG" ]; then
            RELEASE_NOTES=$(git log "$PREV_TAG..$FINAL_VERSION" --pretty=format:"- %s" 2>/dev/null)
          else
            RELEASE_NOTES=$(git log --pretty=format:"- %s" -10 2>/dev/null)
          fi

          gum style --border rounded --border-foreground 240 --padding "0 1" --margin "0 2" --foreground 99 "$ gh release create $FINAL_VERSION --title \"$FINAL_VERSION\""
          if gh release create "$FINAL_VERSION" --title "$FINAL_VERSION" --notes "$RELEASE_NOTES" 2>/dev/null; then
            gum style --foreground {{.SUCCESS}} " Release $FINAL_VERSION créée!"
          else
            gum style --foreground {{.WARNING}} "  Release non créée (peut-être déjà existante)"
          fi
        fi
